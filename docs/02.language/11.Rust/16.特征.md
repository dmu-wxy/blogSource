特征

<!-- more -->

## 特征

Rust中的特征跟接口很类似。特征定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。



### 定义特征

```rust
pub trait Summary {
	fn summarize(&self) -> String;
}
```

这里用 trait 关键字声明了一个特征，很像一个接口。接下来就是实现它:

```rust
pub trait Summary {
	fn summarize(&self) -> String;
}
pub struct Post {
	pub title: String, // 标题
	pub author: String, // 作者
	pub content: String, // 内容
}

impl Summary for Post {
	fn summarize(&self) -> String {
		format!("文章{}, 作者是{}", self.title, self.author)
	}
}

pub struct Weibo {
	pub username: String,
	pub content: String
}

impl Summary for Weibo {
	fn summarize(&self) -> String {
		format!("{}发表了微博{}", self.username, self.content)
	}
}

fn main() {
	let post = Post{title: "Rust语言简介".to_string(),author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
	let weibo = Weibo{username: "sunface".to_string(),content: "好像微博没Tweet好用".to_string()};
	println!("{}",post.summarize());
	println!("{}",weibo.summarize());
}
```

这里定义了两个结构体 微博 和 Post ，他们都实现了Summary这个特征。就这么简单。



### 特征定义与实现的位置（孤儿规则）

关于特征实现与定义的位置，有一条非常重要的原则：如果想要为类型A实现特征T，那么A或者T至少有一个是在当前的作用域中定义的，这条叫做孤儿规则，这样可以确保其他人编写的代码不会破坏你的代码，也确保了你不会莫名其妙破坏了其他代码。因为你不能将别人的类型实现别人的特征。



### 默认实现

可以为特征定义默认的实现方法：

```rust
pub trait Summary {
	fn summarize(&self) -> String {
		String::from("(Read more...)")
	}
}

impl Summary for Post {}
```

默认实现语序调用相同特征中的其他方法，这些方法可以没有默认实现。



## 使用特征作为函数参数

使用特征作为函数参数的作用是参数智能传递实现了这个特征的对象

```rust
pub fn notify(item: &impl Summary) {
	println!("Breaking news! {}", item.summarize());
}
```



## 特征约束（trait bound）

实际上 impl Trait 是一个语法糖，真正的完整书写形式是这样的：

```rust
pub fn notify(item: &T) {
	println!("Breaking news! {}", item.summarize());
}
```

形如 T: Summary 被称为特征约束。

对于复杂的场景，语法糖并不能满足我们的要求，例如特征用在函数参数时不能要求多个参数的类型强制相同（只能要求实现了某个特征），这时就需要特征约束了

```rust
// 必须实现 Summary，并且都是类型T
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```



### 多重约束

同时约束多个特征

```rust
pub fn notify(item: &(impl Summary + Display)) {}

pub fn notify<T: Summary + Display>(item: &T) {}
```



### where 约束

当需要约束的特征很多很多时，建议使用 where 约束，这让方法签名可读性更高

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where T: Display + Clone,
U: Clone + Debug
{}
```



### 使用特征有条件的实现方法和特征

为特定的对象实现方法和特征：

```rust
// T 需要有Display 和 PartialOrd 特征
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```



## 函数返回中使用特征

```rust
fn returns_summarizable() -> impl Summary {
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 max太厉害了，电脑再也不会卡",
        )
    }
}
```

但是要注意，这种方式只能返回一种类型，如果在不同的条件分支中返回了不同的类型，即使它们实现了相同的特征，也会报错。



## derive 派生特征

特征派生语法形如 `#[derive(Debug)]`，被 `derive` 标记的对象会自动实现对应的默认特征代码，继承相应的功能。



## 调用方法需要引入特征

```rust
use std::convert::TryInto;

fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into()
            .unwrap();

  if a < b_ {
    println!("Ten is less than one hundred.");
  }
}
```

这里使用了 try_into 特征，所以需要引入这个特征，但是，把 use 语句删除之后运行不会报错，这是因为Rust把最常用的标准库中的特征通过 `std::prelude` 模块提前引入到当前作用域中，其中包括了 `std::convert::TryInto`.