---
title: OpenGL实战--光照
date: 2023-07-23 22:07:48
permalink: /pages/f0d68b/
categories:
  - 渲染
  - OpenGL
tags:
  - 
---
颜色 / 光照

<!-- more -->

# 颜色

我们所能看到的物体的颜色由**物体本身的颜色**与**光源发出的颜色**的结合而成，在代码中反应为：

```cpp
glm::vec3 lightColor(0.33f,0.42f,0.18f);  // 光源颜色
glm::vec3 toyColor(1.0f,0.5f,0.31f);  // 物体颜色
glm::vec3 result = lightColor * toyColorl; // = (0.33f,0.21f,0.06f)
```



# 光照

冯氏光照模型（Phong Lightint Model）是计算机图形学中一种简化的光照模型，包括环境（Ambient）/ 漫反射（Diffuse）/ 镜面（Specular）光照。

![](https://meteor-pic.oss-cn-shenzhen.aliyuncs.com/image/20230726222650.png)



## 环境光照

**全局照明**表示光可以在一个物体反射然后照亮另一个物体，照亮某一个物体的光可以来源于多个物体反射多次的光线，这样的算法开销高昂并且复杂。**环境关照**是全局照明的一种简化模型，使用一个很小常量的光照颜色，添加到物体最终的颜色中：

```cpp
void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;  // 环境光照

    vec3 result = ambient * objectColor;  // 物体+环境光照
    FragColor = vec4(result, 1.0);
}
```

## 漫反射

计算漫反射需要俩个向量：垂直于顶点表面的向量——法向量，光线方向。然后计算点乘的积，可以得到反射光线的强度。

法向量这里先自行定义然后传到顶点着色器中。

所有光照的计算都是在片段着色器里进行，所以我们需要将法向量由顶点着色器传递到片段着色器：

```
// VS
#version 400 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 Normal;
out vec3 FragPos; // 顶点世界坐标

void main()
{
	gl_Position = projection * view * model * vec4(aPos.x,aPos.y,aPos.z,1.0);
	Normal = aNormal;
	FragPos = vec3(model * vec4(aPos,1.0));
}

// fs
#version 400 core
out vec4 FragColor;
in vec3 Normal;  // 法向量
in vec3 FragPos;  // 顶点世界坐标

uniform vec3 objectColor;  // 物体颜色
uniform vec3 lightColor;  // 光源颜色
uniform vec3 lightPos;  // 光源位置

void main(){
	// 计算漫反射, 光线方向和法向量的点乘（两个向量都需要标准化）
	vec3 norm = normalize(Normal);
	vec3 lightDir = normalize(lightPos - FragPos);
	float diff = max(dot(norm,lightDir),0.0);
	vec3 diffUse = diff * lightColor;

	// 环境光照
	float ambientStrength = 0.1; 
	vec3 ambient  = ambientStrength * lightColor;

	// 最终将漫反射光线和环境关照相加
	vec3 result = (ambient + diffUse) * objectColor;
	FragColor = vec4(result,1.0);
}
```

## 小插曲

目前在片段着色器中，计算都是在世界坐标中进行的，所以法向量也应该转换为世界坐标。

但是法向量转换为世界坐标不能乘以一个模型矩阵来转换，因为法向量是没有方向的，不能被位移部分影响。解决方法就是只用模型矩阵的左上角3*3矩阵，只对法向量实施缩放和旋转变换。

同时，如果模型执行了不等比的缩放（三个轴缩放比例不同），会导致法向量不在垂直于表面，光照被破坏。

解决方法就是制作专门的矩阵——法线矩阵。[如何计算](http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/)

```
// inverse 求逆矩阵，开销很大
// transpose 求转置矩阵
Normal = mat3(transpose(inverse(model))) * aNormal;
```

## 镜面光照

镜面光照不仅取决于光的方向向量和物体的法向量，还取决于观察方向。

```
float specularStrength = 0.5;  // 镜面强度
vec3 viewDir = normalize(viewPos - FragPos);
vec3 reflectDir = reflect(-lightDir, norm);
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);  // 32次幂，高光的反光度
vec3 specular = specularStrength * spec * lightColor;
```

