OpenXR 部分翻译

<!-- more -->

> XR：计算机通过人机交互产生的虚实环境连续统一体，包括VR,AR,MR。

> OpenXR是一个针对XR应用程序接口，简称API。
>
> OpenXR的最终目标是将VR/AR应用和头显之间的通信方式标准化。

[The OpenXR Specification](https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#extension-appendices-list)

# 1. Introduction

## 1.1 what is OpenXR

OpenXR 是 XR应用程序的 API，XR 是指计算机通过人机交互生成的一个真实和虚拟的组合环境的连续统一体，包括与虚拟现实(VR)、增强现实(AR)和混合现实(MR)相关的技术。

OpenXR是程序和 运行时 的接口，运行时有帧组合、外围设备管理和原始追踪信息的功能。

运行时 可以提供设备层插件，以访问各种硬件通过通用接口。



## 1.2 The Programmer's View of OpenXR

对于开发者，OpenXR是一组运行时接口的函数，用于执行通常需要的操作。



- 一个典型的OpenXR程序从调用创建一个实例开始，该实例建立到运行时的连接；
- 然后调用来创建一个系统，该系统选择使用物理显示器和输出、跟踪和图形设备的子集；
- 随后调用以创建缓冲区，应用程序将使用适合平台的图形 API 在其中呈现一个或多个视图；
- 最后调用创建一个会话并开始应用程序的 XR 呈现循环。



## 1.3 The Implementor’s View of OpenXR

对于运行时实现者来说，OpenXR 是一组控制 XR 系统操作并建立 XR 应用程序生命周期的函数。

## 1.4 Our View of OpenXR

我们将 OpenXR 视为以平台无关的方式与 VR/AR/MR 系统交互的机制。



# 2. Fundamentals

## 2.1 API Version

`major_version.minor_version.patch_version`

```cpp
// Provided by XR_VERSION_1_0
typedef uint64_t XrVersion;
```

> - The major version number is a 16-bit integer packed into bits 63-48.
> - The minor version number is a 16-bit integer packed into bits 47-32.
> - The patch version number is a 32-bit integer packed into bits 31-0.



- 补丁版本号的差异表明规范或标头的一些通常较小的部分已经被修改，通常是为了修复 bug，并且可能对现有功能的行为产生影响;
- 次要版本号的差异表明添加了一些新功能;
- 主要版本号的差异表明 API 有很大的变化，可能包括新的功能和头接口、行为变化、去除废弃特性、修改或完全替换任何特性，因此很可能破坏兼容性。

## 2.2 String Encoding

`utf-8`

## 2.3 Threading Behavior

OpenXR API 旨在提供在多个主机线程上使用时的可伸缩性能。所有函数都必须支持从多个线程并发调用，但是某些参数或参数的组件被定义为外部同步。这意味着调用方必须保证在给定的时间内不会有多个线程使用这样的参数。

## 2.4 Multiprocessing Behavior

OpenXR API不显式识别，也不要求同时支持多个进程使用运行时，也不阻止运行时提供这样的支持。

## 2.5 Runtime

OpenXR运行时是实现OpenXR API的软件。在一个系统上可能安装了多个OpenXR运行时，但是在任何给定的时间里只有一个运行时是活动的。

## 2.6 Extensions

OpenXR是一个可扩展的API，它可以通过添加新特性实现增长。扩展可以用于公开新的OpenXR函数或修改现有OpenXR函数的行为。因为扩展是可选的，所以它们只能在运行时、图形平台或操作系统的子集上实现。因此，应用程序在启用扩展之前应该首先查询哪些扩展可用。

应用程序使用 `xrEnumerateInstanceExtensionProperties` 函数查询可用的扩展列表。一旦应用程序确定支持哪些目标扩展，它就可以在调用 `xrCreateInstance` 期间启用它们的某些子集。

OpenXR扩展具有唯一的名称，用于传递所提供功能的信息。名称格式如下: `XR_KHR_composition_layer_cube`

## 2.7 API Layers

OpenXR被设计成一个分层的API，这意味着用户或应用程序可以在应用程序和运行时实现之间插入API层。这些API层通过拦截上面一层的OpenXR函数，然后执行不同于没有该层时执行的操作，从而提供了额外的功能。在最简单的情况下，层只是用相同的参数调用下一层，但更复杂的层可能实现层或运行时中不存在的API功能。这种机制本质上是一种架构化的“function shimming”或“拦截”特性，它被设计到OpenXR中，旨在取代“挂钩”API调用的更非正式的方法。

### 2.7.1 Examples of API Layers

- Validation Layer 验证层
- API Logging Layer 日志层
- API Trace Layer 追踪层

### 2.7.2 Naming API Layers

为了组织API层名称并防止API层名称命名空间中的冲突，API层必须使用以下约定命名:

```
XR_APILAYER_<VENDOR-TAG>_short_name
```

### 2.7.3 Activating API Layers

- Application Activation: 程序通过调用 `xrEnumerateApiLayerProperties` 函数获得支持的API层，通过 `xrCreateInstance` 函数创建实例
- System Activation: 可以通过配置系统来激活 API 

### 2.7.4 API Layer Extensions

API 层可能实现 OpenXR 函数，底层 运行时 可能支持也可能不支持这些函数。为了公开这些新特性，API层必须以OpenXR扩展的形式公开该功能。它不能在没有相关扩展的情况下公开新的OpenXR函数。

要找出API层支持的扩展，应用程序必须首先通过调用 `xrEnumerateApiLayerProperties` 来验证当前系统上是否存在API层。在验证存在感兴趣的API层之后，应用程序应该调用  `xrEnumerateInstanceExtensionProperties` 并提供API层名称作为第一个参数。这将返回该API层内部实现的扩展列表。

### 2.7.5 Type Aliasing ?

OpenXR规范不支持严格的别名，因为在某些情况下，应用程序有意提供的结构与声明的类型不同。

*看不懂*

### 2.7.6 Valid Usage ?

有效使用定义了一组必须满足的条件，以便在应用程序中实现良好定义的运行时行为（Valid usage defines a set of conditions which **must** be met in order to achieve well-defined run-time behavior in an application）。这些条件只依赖于API的状态，以及使用受此条件约束的参数或对象。

### 2.7.7 Implicit Valid Usage

一些有效的使用条件适用于API中的所有函数和结构，除非对特定的函数或结构显式地另有指示。(Some valid usage conditions apply to all functions and structures in the API, unless explicitly denoted otherwise for a specific function or structure.)

- 对象句柄的有效用法

  除非另有说明，函数的任何作为对象句柄的输入参数都必须是有效的对象句柄。

  > - 它是由之前成功调用API创建或分配的
  > - 它没有被之前的API调用销毁
  > - 它的父句柄也有效

- 指针的有效用法

  当规范指示运行时使用指针时，指针形参必须是有效指针。

  指针有效：指针指向的内存中包含函数所期望的数值和类型，并且通过指针访问的所有基本类型(如数组元素或结构成员)满足主机处理器的对齐要求。

- 枚举类型的有效用法

  枚举类型的任何参数都必须是该类型的有效枚举数。

  有效：枚举数定义为所涉及的枚举类型的一部分。

- 标志的有效使用

  标志集合由XrFlags64类型的位掩码表示：

  ```cpp
  typedef uint64_t XrFlags64;
  ```

  该API并不直接使用XrFlags64类型。相反，使用Xr*Flags类型，它是XrFlags64类型的别名。该API还定义了一组用于设置位掩码的常量位定义。

  API中使用的任何Xr*Flags成员或参数必须是位标志的有效组合.

  > - 位标志是与Xr*Flags成员或参数相同的Xr*Flags类型定义的常量位之一。有效的标志值也可以由扩展定义。
  > - 该标志在使用它的上下文中是允许的。

- 结构类型的有效使用

  任何包含类型成员的结构参数都必须具有与结构类型匹配的有效XrStructureType值的类型。作为一般规则，该值的名称通过以下方式获得:取结构名，去掉前导Xr，在每个大写字母前加上下划线，将整个结果字符串转换为大写，并在其前加上XR_TYPE_。该规则的唯一例外是API和操作系统名称（OpenGL -> _OPENGL）

- 结构指针链的有效使用

  任何包含void* next成员的结构必须具有next的值，该值要么为NULL，要么指向同时包含类型和next成员值的有效结构。

  除非另有说明:作为输出结构的链式结构可以由运行时修改，类型和next字段除外。从任何函数返回时，链中的所有类型和next字段都不能修改。

  - 有用的基础结构

    为了方便运行时和层需要通过结构指针链进行迭代，OpenXR API提供了以下基本结构:

    ```cpp
    // Provided by XR_VERSION_1_0
    // 用于方便遍历只读结构指针链。
    typedef struct XrBaseInStructure {
        XrStructureType                    type;
        const struct XrBaseInStructure*    next;
    } XrBaseInStructure;
    
    // Provided by XR_VERSION_1_0
    // 用于方便遍历将数据返回给应用程序的结构指针链。
    typedef struct XrBaseOutStructure {
        XrStructureType               type;
        struct XrBaseOutStructure*    next;
    } XrBaseOutStructure;
    ```

  - 下一链（Next Chain）结构唯一性

    应用程序应该确保在给定的next链中创建和插入每种类型的扩展结构的次数不超过一次

- 嵌套结构的有效用法

## 2.8 Return Codes

虽然核心API的设计目的不是捕获不正确的使用，但在某些情况下仍然需要返回代码。API中的函数通过以下两类之一的返回码返回它们的状态。

- 当函数需要传递成功或状态信息时，将返回成功完成代码。所有成功的完成代码都是非负值的。
- 当函数需要传递只能在运行时检测到的故障时，将返回运行时错误代码。所有运行时错误码都是负值。

返回类型为：`XrResult`

常见后缀：

- _INVALID：指定的句柄、原子或值格式化不正确，或指定的句柄从未创建或已销毁。
- _UNSUPPORTED：指定的句柄、原子、枚举或值已正确格式化，但不能在此函数父句柄的生命周期内使用。
- _UNAVAILABLE：该函数的父句柄支持指定的句柄、原子句柄、枚举句柄或值句柄，但目前不支持。

### 2.8.1 Convenience Macros

```cpp
#define XR_SUCCEEDED(result) ((result) >= 0)
#define XR_FAILED(result) ((result) < 0)
#define XR_UNQUALIFIED_SUCCESS(result) ((result) == 0)
```

### 2.8.2 Validation

运行时 可能会选择验证某些API的使用并返回适当的错误代码。

如果函数返回运行时错误，除非另有指定，否则任何输出参数都将具有未定义的内容，除非输出参数是带有type和next字段的结构体，否则这些字段将不会被修改。从next链接的任何输出结构也将具有未定义的内容，除了类型和next将不被修改。

## 2.9 Handles

由运行时代表应用程序分配的对象由句柄表示。句柄是对象的不透明标识符，其生命周期由应用程序通过创建和销毁函数控制。示例句柄类型包括 `XrInstance` 、`XrSession` 和 `XrSwapchain` 。

对于给定的应用进程来说，没有被销毁的句柄是唯一的，但是在销毁之后可以被重用。

句柄形成了一个层次结构，其中子句柄受父句柄的有效性和生命周期的影响。例如，要创建一个 `XrSwapchain` 句柄，应用程序必须调用 `xrcreateswaapchain` 并传递一个 `XrSession` 句柄。因此 `XrSwapchain` 是 `XrSession` 的子句柄。

## 2.10 Object Handle Types

函数中使用的对象句柄类型通常由该函数的规范决定，如在对象句柄的有效用法中所讨论的。但是，有些函数接受或返回对象句柄参数，其中对象句柄的类型在执行时未知，并且没有在函数本身的描述中指定。对于这些函数，可以使用 `XrObjectType` 显式地指定句柄的类型。

## 2.11 Buffer Size Parameters

带有输入/输出缓冲区形参的函数采用形参形式或结构形式，类似于下面的示例之一，在本例中元素类型为float:

```cpp
// Parameter form
XrResult xrFunction(uint32_t elementCapacityInput, uint32_t* elementCountOutput, float* elements);

// Struct form
XrResult xrFunction(XrBuffer* buffer);

struct XrBuffer {
    uint32_t              elementCapacityInput;
    uint32_t              elementCountOutput;
    float*                elements;
};
```

## 2.12 Time

时间由一个64位有符号整数表示，该整数表示纳秒(XrTime)：

```cpp
typedef int64_t XrTime;
```