---
title: 垃圾回收
date: 2021-03-16 17:50:31
permalink: /pages/751b27/
categories:
  - 更多
  - 面试
  - Java基础
tags:
  - 
---
垃圾回收机制

<!-- more -->

[参考@我是程序员](https://zhuanlan.zhihu.com/p/73628158)



# 定义垃圾

## 引用计数算法

引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。



问题：

当两个对象互相引用，那么这两个对象的引用计数永远不会到0，也就不会回收。



## 可达性分析算法

可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。



<img src="https://pic3.zhimg.com/80/v2-43ddfa6f70d6c3fde381454105af6472_720w.jpg" alt="可达性分析算法" style="zoom:100%;" />



# 回收垃圾

## 标记清除算法

将标记为垃圾的对象清楚使该处的内存区域变为未使用。

缺点：不对内存进行整理，会产生很多内存碎片，可能会让许多区域因为不够大而用不了。

![标记清除算法](https://pic1.zhimg.com/80/v2-20129b9cd43d0f9b3bd37537d639464c_720w.jpg)

## 复制算法

复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。

缺点：将内存对半分使用，代价太高。

![复制算法](https://pic4.zhimg.com/80/v2-bb9ee29feb22355eed2c1d3ac45606b7_720w.jpg)

## 标记整理算法

将存活的对象整体向前移，再清理掉后面可回收的对象。

缺点：对内存的变动更加频繁，效率要差很多。

![标记整理算法](https://pic1.zhimg.com/80/v2-49f3e16de8d552ef585862062abe3f18_720w.jpg)

## 分代收集算法

分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。

对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 --- 整理算法来进行回收。

### 内存模型与回收策略

*Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。*



![内存模型](https://pic4.zhimg.com/80/v2-2dcba4d81807c67df8309aa181bb00c3_720w.jpg)



- Eden区：

  IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。

  通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

- Survivor区：

  Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。

  > 1. 为啥需要
  >
  >    有一些类虽然并不是只用一次，但是也用不了多少次，所以Survivor相当于一个缓冲区，保证只有经历16次Minor GC还能在新生代存活的对象才能进老年区，减少Major GC的发生。
  >
  > 2. 为啥需要俩
  >
  >    主要是解决内存碎片化。
  >
  >    因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。
  >
  >    当然更多会导致每块变小，更容易满。

- Old区：

  只有在Major的时候才会进行清理，采用标记整理算法。

  下面几种对象会直接进入到老年代：

  - 大对象：即使是使用几次就回收的，是为了防止大内存的复制。
  - 长期存活对象：虚拟机定义了对象年龄计数器，每经历一次Minor GC，年龄增加一岁，默认15岁进老年区。
  - 动态对象年龄：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。



