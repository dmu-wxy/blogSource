---
title: 锁
date: 2021-03-15 22:49:04
permalink: /pages/b4a65f/
categories:
  - 更多
  - 面试
  - Java基础
tags:
  - 
---
synchronized/lock、乐观锁/悲观锁、自旋锁、偏向锁/轻量级锁/重量级锁、可重入锁、公平锁/非公平锁、可中断锁、读写锁、共享锁、互斥锁.

<!-- more -->

[参考@Pickle Pee](https://zhuanlan.zhihu.com/p/71156910)

# 0.synchronized和lock

Java中有两种加锁的方式：一种是用**synchronized关键字**，另一种是用**Lock接口**的实现类。



形象地说，synchronized关键字是**自动档**，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要**手动档**了——各种Lock的实现类。



所以如果你只是想要简单的加个锁，对性能也没什么特别的要求，用synchronized关键字就足够了。自Java 5之后，才在java.util.concurrent.locks包下有了另外一种方式来实现锁，那就是Lock。也就是说，**synchronized是Java语言内置的关键字，而Lock是一个接口**，这个接口的实现类在代码层面实现了锁的功能。



# 1.悲观锁与乐观锁

悲观锁和乐观锁并不是指某个类，而是在并发情况下的两种不同策略。



- 悲观锁：悲观的认为每次拿数据的时候别人都会修改，所以每次拿数据的时候都会上锁，这样别人在拿数据的时候，就会被挡住。
- 乐观锁：乐观的认为每次拿数据的时候别人都不会修改，所以不会上锁，在更新的时候会比较拿到的数据和修改后要覆盖的数据是否一样，一样则覆盖，不一样则表示这段时间该数据被修改过，再次尝试更新，循环到更新成功或者放弃操作。



**悲观锁阻塞事务，乐观锁回滚重试**，各有优缺点，乐观锁更适合写比较少的时候。



## 1.2 乐观锁基础CAS

说到乐观锁，就必须提到一个概念：**CAS**

什么是CAS呢？Compare-and-Swap，即**比较并替换，**也有叫做Compare-and-Set的，**比较并设置**。

1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。

2、设置：如果是，将A更新为B，结束。[[1\]](https://zhuanlan.zhihu.com/p/71156910#ref_1)如果不是，则什么都不做。

上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。

有了CAS，就可以实现一个**乐观锁**：

```java
data = 123; // 共享数据

/* 更新数据的线程会进行如下操作 */
flag = true;
while (flag) {
    oldValue = data; // 保存原始数据
    newValue = doSomething(oldValue); 

    // 下面的部分为CAS操作，尝试更新data的值
    if (data == oldValue) { // 比较
        data = newValue; // 设置
        flag = false; // 结束
    } else {
	// 啥也不干，循环重试
    }
}
/* 
   很明显，这样的代码根本不是原子性的，
   因为真正的CAS利用了CPU指令，
   这里只是为了展示执行流程，本意是一样的。
*/
```



因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为**无锁编程**。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！



# 2. 自旋锁

所谓自旋，说白了就是一个 while(true) 无限循环。但是乐观锁并不是自旋锁，尽管自旋与 while(true) 的操作是一样的，但还是应该将这两个术语分开。“自旋”这两个字，特指自旋锁的自旋。



下面的轻量级锁就是一种自旋锁。



# 3.synchronized锁升级：偏向锁-》轻量级锁-》重量级锁

synchronized关键字就像汽车的自动挡，随着线程的增多，synchronized会从**无锁**升级为**偏向锁**，再升级为**轻量级锁**，最后升级为**重量级锁**。



- 偏向锁

  初次执行到synchronized代码块的时候，锁对象变成**偏向锁**（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并**不会主动释放偏向锁**。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。**由于之前没有释放锁，这里也就不需要重新加锁。**如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

- 轻量级锁（自旋锁）

  一旦有第二个线程加入**锁竞争**，偏向锁就升级为**轻量级锁（自旋锁）**。此时进入忙等（线程循环获取锁，空耗CPU，）

  > 如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

- 重量级锁

  短时间的忙等可以换取线程在用户态和核心态切换的开销。但长时间的忙等（有计数器记录自选次数，默认10次，可以通过虚拟机更改），会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现锁的重量级锁，则自己挂起。



*一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫**锁膨胀**的），不允许降级。*



# 4.可重入锁（递归锁）

允许同一个线程多次获取同一把锁。



Java里只要以Reentrant开头命名的锁都是可重入锁，而且**JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。**如果你需要不可重入锁，只能自己去实现了。



# 5.公平锁、非公平锁

如果多个线程申请一把**公平锁**，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是**非公平锁**，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。



对ReentrantLock类而言，通过构造函数传参**可以指定该锁是否是公平锁（true），默认是非公平锁(false)**。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。



对于synchronized而言，它也是一种**非公平锁**，但是并没有任何办法使其变成公平锁。



# 6.可中断锁

“可以响应中断的锁”，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是**可中断锁**。



在Java中，synchronized就是**不可中断锁**，而Lock的实现类都是**可中断锁**。



> 这里的关键是理解什么是**中断**。Java并没有提供任何直接中断某线程的方法，只提供了**中断机制**。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的**中断不能直接终止线程**，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己



Lock接口：

```java
/* Lock接口 */
public interface Lock {

    void lock(); // 拿不到锁就一直等，拿到马上返回。

    void lockInterruptibly() throws InterruptedException; // 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。

    boolean tryLock(); // 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。

    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 同上，可以自定义等待的时间。

    void unlock();

    Condition newCondition();
}
```



# 7.读写锁、共享锁、互斥锁

读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排它锁）。



读写锁其实做的事情是一样的，但是策略稍有不同。很多情况下，线程知道自己读取数据后，是否是为了更新它。那么何不在加锁的时候直接明确这一点呢？如果我读取值是为了更新它（SQL的for update就是这个意思），那么加锁的时候就直接加**写锁**，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅为了前端展示，那么加锁时就明确地加一个**读锁，**其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）。



虽然读写锁感觉与乐观锁有点像，但是**读写锁是悲观锁策略**。因为读写锁并没有在**更新前**判断值有没有被修改过，而是在**加锁前**决定应该用读锁还是写锁。乐观锁特指无锁编程，如果仍有疑惑可以再回到第一、二小节，看一下什么是“乐观锁”。

