{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{453:function(s,t,a){\"use strict\";a.r(t);var n=a(15),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[a(\"p\",[s._v(\"synchronized/lock、乐观锁/悲观锁、自旋锁、偏向锁/轻量级锁/重量级锁、可重入锁、公平锁/非公平锁、可中断锁、读写锁、共享锁、互斥锁.\")]),s._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/71156910\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"参考@Pickle Pee\"),a(\"OutboundLink\")],1)]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_0-synchronized和lock\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_0-synchronized和lock\"}},[s._v(\"#\")]),s._v(\" 0.synchronized和lock\")]),s._v(\" \"),a(\"p\",[s._v(\"Java中有两种加锁的方式：一种是用\"),a(\"strong\",[s._v(\"synchronized关键字\")]),s._v(\"，另一种是用\"),a(\"strong\",[s._v(\"Lock接口\")]),s._v(\"的实现类。\")]),s._v(\" \"),a(\"p\",[s._v(\"形象地说，synchronized关键字是\"),a(\"strong\",[s._v(\"自动档\")]),s._v(\"，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要\"),a(\"strong\",[s._v(\"手动档\")]),s._v(\"了——各种Lock的实现类。\")]),s._v(\" \"),a(\"p\",[s._v(\"所以如果你只是想要简单的加个锁，对性能也没什么特别的要求，用synchronized关键字就足够了。自Java 5之后，才在java.util.concurrent.locks包下有了另外一种方式来实现锁，那就是Lock。也就是说，\"),a(\"strong\",[s._v(\"synchronized是Java语言内置的关键字，而Lock是一个接口\")]),s._v(\"，这个接口的实现类在代码层面实现了锁的功能。\")]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_1-悲观锁与乐观锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-悲观锁与乐观锁\"}},[s._v(\"#\")]),s._v(\" 1.悲观锁与乐观锁\")]),s._v(\" \"),a(\"p\",[s._v(\"悲观锁和乐观锁并不是指某个类，而是在并发情况下的两种不同策略。\")]),s._v(\" \"),a(\"ul\",[a(\"li\",[s._v(\"悲观锁：悲观的认为每次拿数据的时候别人都会修改，所以每次拿数据的时候都会上锁，这样别人在拿数据的时候，就会被挡住。\")]),s._v(\" \"),a(\"li\",[s._v(\"乐观锁：乐观的认为每次拿数据的时候别人都不会修改，所以不会上锁，在更新的时候会比较拿到的数据和修改后要覆盖的数据是否一样，一样则覆盖，不一样则表示这段时间该数据被修改过，再次尝试更新，循环到更新成功或者放弃操作。\")])]),s._v(\" \"),a(\"p\",[a(\"strong\",[s._v(\"悲观锁阻塞事务，乐观锁回滚重试\")]),s._v(\"，各有优缺点，乐观锁更适合写比较少的时候。\")]),s._v(\" \"),a(\"h2\",{attrs:{id:\"_1-2-乐观锁基础cas\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-乐观锁基础cas\"}},[s._v(\"#\")]),s._v(\" 1.2 乐观锁基础CAS\")]),s._v(\" \"),a(\"p\",[s._v(\"说到乐观锁，就必须提到一个概念：\"),a(\"strong\",[s._v(\"CAS\")])]),s._v(\" \"),a(\"p\",[s._v(\"什么是CAS呢？Compare-and-Swap，即**比较并替换，**也有叫做Compare-and-Set的，\"),a(\"strong\",[s._v(\"比较并设置\")]),s._v(\"。\")]),s._v(\" \"),a(\"p\",[s._v(\"1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。\")]),s._v(\" \"),a(\"p\",[s._v(\"2、设置：如果是，将A更新为B，结束。[\"),a(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/71156910#ref_1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"1]\"),a(\"OutboundLink\")],1),s._v(\"如果不是，则什么都不做。\")]),s._v(\" \"),a(\"p\",[s._v(\"上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。\")]),s._v(\" \"),a(\"p\",[s._v(\"有了CAS，就可以实现一个\"),a(\"strong\",[s._v(\"乐观锁\")]),s._v(\"：\")]),s._v(\" \"),a(\"div\",{staticClass:\"language-java line-numbers-mode\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[s._v(\"data \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"123\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 共享数据\")]),s._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"/* 更新数据的线程会进行如下操作 */\")]),s._v(\"\\nflag \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[s._v(\"true\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"while\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),s._v(\"flag\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n    oldValue \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" data\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 保存原始数据\")]),s._v(\"\\n    newValue \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"doSomething\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),s._v(\"oldValue\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 下面的部分为CAS操作，尝试更新data的值\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"if\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),s._v(\"data \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"==\")]),s._v(\" oldValue\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 比较\")]),s._v(\"\\n        data \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" newValue\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 设置\")]),s._v(\"\\n        flag \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[s._v(\"false\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 结束\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"else\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 啥也不干，循环重试\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"/* \\n   很明显，这样的代码根本不是原子性的，\\n   因为真正的CAS利用了CPU指令，\\n   这里只是为了展示执行流程，本意是一样的。\\n*/\")]),s._v(\"\\n\")])]),s._v(\" \"),a(\"div\",{staticClass:\"line-numbers-wrapper\"},[a(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),a(\"br\")])]),a(\"p\",[s._v(\"因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为\"),a(\"strong\",[s._v(\"无锁编程\")]),s._v(\"。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！\")]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_2-自旋锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-自旋锁\"}},[s._v(\"#\")]),s._v(\" 2. 自旋锁\")]),s._v(\" \"),a(\"p\",[s._v(\"所谓自旋，说白了就是一个 while(true) 无限循环。但是乐观锁并不是自旋锁，尽管自旋与 while(true) 的操作是一样的，但还是应该将这两个术语分开。“自旋”这两个字，特指自旋锁的自旋。\")]),s._v(\" \"),a(\"p\",[s._v(\"下面的轻量级锁就是一种自旋锁。\")]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_3-synchronized锁升级-偏向锁-》轻量级锁-》重量级锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-synchronized锁升级-偏向锁-》轻量级锁-》重量级锁\"}},[s._v(\"#\")]),s._v(\" 3.synchronized锁升级：偏向锁-》轻量级锁-》重量级锁\")]),s._v(\" \"),a(\"p\",[s._v(\"synchronized关键字就像汽车的自动挡，随着线程的增多，synchronized会从\"),a(\"strong\",[s._v(\"无锁\")]),s._v(\"升级为\"),a(\"strong\",[s._v(\"偏向锁\")]),s._v(\"，再升级为\"),a(\"strong\",[s._v(\"轻量级锁\")]),s._v(\"，最后升级为\"),a(\"strong\",[s._v(\"重量级锁\")]),s._v(\"。\")]),s._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[s._v(\"偏向锁\")]),s._v(\" \"),a(\"p\",[s._v(\"初次执行到synchronized代码块的时候，锁对象变成\"),a(\"strong\",[s._v(\"偏向锁\")]),s._v(\"（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并\"),a(\"strong\",[s._v(\"不会主动释放偏向锁\")]),s._v(\"。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。**由于之前没有释放锁，这里也就不需要重新加锁。**如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。\")])]),s._v(\" \"),a(\"li\",[a(\"p\",[s._v(\"轻量级锁（自旋锁）\")]),s._v(\" \"),a(\"p\",[s._v(\"一旦有第二个线程加入\"),a(\"strong\",[s._v(\"锁竞争\")]),s._v(\"，偏向锁就升级为\"),a(\"strong\",[s._v(\"轻量级锁（自旋锁）\")]),s._v(\"。此时进入忙等（线程循环获取锁，空耗CPU，）\")]),s._v(\" \"),a(\"blockquote\",[a(\"p\",[s._v(\"如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。\")])])]),s._v(\" \"),a(\"li\",[a(\"p\",[s._v(\"重量级锁\")]),s._v(\" \"),a(\"p\",[s._v(\"短时间的忙等可以换取线程在用户态和核心态切换的开销。但长时间的忙等（有计数器记录自选次数，默认10次，可以通过虚拟机更改），会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现锁的重量级锁，则自己挂起。\")])])]),s._v(\" \"),a(\"p\",[a(\"em\",[s._v(\"一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫\"),a(\"strong\",[s._v(\"锁膨胀\")]),s._v(\"的），不允许降级。\")])]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_4-可重入锁-递归锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-可重入锁-递归锁\"}},[s._v(\"#\")]),s._v(\" 4.可重入锁（递归锁）\")]),s._v(\" \"),a(\"p\",[s._v(\"允许同一个线程多次获取同一把锁。\")]),s._v(\" \"),a(\"p\",[s._v(\"Java里只要以Reentrant开头命名的锁都是可重入锁，而且**JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。**如果你需要不可重入锁，只能自己去实现了。\")]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_5-公平锁、非公平锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-公平锁、非公平锁\"}},[s._v(\"#\")]),s._v(\" 5.公平锁、非公平锁\")]),s._v(\" \"),a(\"p\",[s._v(\"如果多个线程申请一把\"),a(\"strong\",[s._v(\"公平锁\")]),s._v(\"，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是\"),a(\"strong\",[s._v(\"非公平锁\")]),s._v(\"，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。\")]),s._v(\" \"),a(\"p\",[s._v(\"对ReentrantLock类而言，通过构造函数传参\"),a(\"strong\",[s._v(\"可以指定该锁是否是公平锁（true），默认是非公平锁(false)\")]),s._v(\"。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。\")]),s._v(\" \"),a(\"p\",[s._v(\"对于synchronized而言，它也是一种\"),a(\"strong\",[s._v(\"非公平锁\")]),s._v(\"，但是并没有任何办法使其变成公平锁。\")]),s._v(\" \"),a(\"h1\",{attrs:{id:\"_6-可中断锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-可中断锁\"}},[s._v(\"#\")]),s._v(\" 6.可中断锁\")]),s._v(\" \"),a(\"p\",[s._v(\"“可以响应中断的锁”，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是\"),a(\"strong\",[s._v(\"可中断锁\")]),s._v(\"。\")]),s._v(\" \"),a(\"p\",[s._v(\"在Java中，synchronized就是\"),a(\"strong\",[s._v(\"不可中断锁\")]),s._v(\"，而Lock的实现类都是\"),a(\"strong\",[s._v(\"可中断锁\")]),s._v(\"。\")]),s._v(\" \"),a(\"blockquote\",[a(\"p\",[s._v(\"这里的关键是理解什么是\"),a(\"strong\",[s._v(\"中断\")]),s._v(\"。Java并没有提供任何直接中断某线程的方法，只提供了\"),a(\"strong\",[s._v(\"中断机制\")]),s._v(\"。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的\"),a(\"strong\",[s._v(\"中断不能直接终止线程\")]),s._v(\"，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己\")])]),s._v(\" \"),a(\"p\",[s._v(\"Lock接口：\")]),s._v(\" \"),a(\"div\",{staticClass:\"language-java line-numbers-mode\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"/* Lock接口 */\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"public\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"interface\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"Lock\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"void\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"lock\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 拿不到锁就一直等，拿到马上返回。\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"void\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"lockInterruptibly\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"throws\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"InterruptedException\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"boolean\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"tryLock\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"boolean\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"tryLock\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"long\")]),s._v(\" time\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"TimeUnit\")]),s._v(\" unit\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"throws\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"InterruptedException\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"// 同上，可以自定义等待的时间。\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"void\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"unlock\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"Condition\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[s._v(\"newCondition\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\")])]),s._v(\" \"),a(\"div\",{staticClass:\"line-numbers-wrapper\"},[a(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),a(\"br\")])]),a(\"h1\",{attrs:{id:\"_7-读写锁、共享锁、互斥锁\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-读写锁、共享锁、互斥锁\"}},[s._v(\"#\")]),s._v(\" 7.读写锁、共享锁、互斥锁\")]),s._v(\" \"),a(\"p\",[s._v(\"读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排它锁）。\")]),s._v(\" \"),a(\"p\",[s._v(\"读写锁其实做的事情是一样的，但是策略稍有不同。很多情况下，线程知道自己读取数据后，是否是为了更新它。那么何不在加锁的时候直接明确这一点呢？如果我读取值是为了更新它（SQL的for update就是这个意思），那么加锁的时候就直接加\"),a(\"strong\",[s._v(\"写锁\")]),s._v(\"，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅为了前端展示，那么加锁时就明确地加一个**读锁，**其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）。\")]),s._v(\" \"),a(\"p\",[s._v(\"虽然读写锁感觉与乐观锁有点像，但是\"),a(\"strong\",[s._v(\"读写锁是悲观锁策略\")]),s._v(\"。因为读写锁并没有在\"),a(\"strong\",[s._v(\"更新前\")]),s._v(\"判断值有没有被修改过，而是在\"),a(\"strong\",[s._v(\"加锁前\")]),s._v(\"决定应该用读锁还是写锁。乐观锁特指无锁编程，如果仍有疑惑可以再回到第一、二小节，看一下什么是“乐观锁”。\")])])}),[],!1,null,null,null);t.default=e.exports}}]);","extractedComments":[]}