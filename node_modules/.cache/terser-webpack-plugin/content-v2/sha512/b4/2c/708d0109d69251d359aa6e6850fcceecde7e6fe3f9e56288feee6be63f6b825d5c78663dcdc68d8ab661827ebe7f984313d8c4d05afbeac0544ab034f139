{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{455:function(v,t,r){\"use strict\";r.r(t);var a=r(15),_=Object(a.a)({},(function(){var v=this,t=v.$createElement,r=v._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[r(\"p\",[v._v(\"垃圾回收机制\")]),v._v(\" \"),r(\"p\",[r(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/73628158\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"参考@我是程序员\"),r(\"OutboundLink\")],1)]),v._v(\" \"),r(\"h1\",{attrs:{id:\"定义垃圾\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义垃圾\"}},[v._v(\"#\")]),v._v(\" 定义垃圾\")]),v._v(\" \"),r(\"h2\",{attrs:{id:\"引用计数算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#引用计数算法\"}},[v._v(\"#\")]),v._v(\" 引用计数算法\")]),v._v(\" \"),r(\"p\",[v._v(\"引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。\")]),v._v(\" \"),r(\"p\",[v._v(\"问题：\")]),v._v(\" \"),r(\"p\",[v._v(\"当两个对象互相引用，那么这两个对象的引用计数永远不会到0，也就不会回收。\")]),v._v(\" \"),r(\"h2\",{attrs:{id:\"可达性分析算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可达性分析算法\"}},[v._v(\"#\")]),v._v(\" 可达性分析算法\")]),v._v(\" \"),r(\"p\",[v._v(\"可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。\")]),v._v(\" \"),r(\"img\",{staticStyle:{zoom:\"100%\"},attrs:{src:\"https://pic3.zhimg.com/80/v2-43ddfa6f70d6c3fde381454105af6472_720w.jpg\",alt:\"可达性分析算法\"}}),v._v(\" \"),r(\"h1\",{attrs:{id:\"回收垃圾\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#回收垃圾\"}},[v._v(\"#\")]),v._v(\" 回收垃圾\")]),v._v(\" \"),r(\"h2\",{attrs:{id:\"标记清除算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#标记清除算法\"}},[v._v(\"#\")]),v._v(\" 标记清除算法\")]),v._v(\" \"),r(\"p\",[v._v(\"将标记为垃圾的对象清楚使该处的内存区域变为未使用。\")]),v._v(\" \"),r(\"p\",[v._v(\"缺点：不对内存进行整理，会产生很多内存碎片，可能会让许多区域因为不够大而用不了。\")]),v._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://pic1.zhimg.com/80/v2-20129b9cd43d0f9b3bd37537d639464c_720w.jpg\",alt:\"标记清除算法\"}})]),v._v(\" \"),r(\"h2\",{attrs:{id:\"复制算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制算法\"}},[v._v(\"#\")]),v._v(\" 复制算法\")]),v._v(\" \"),r(\"p\",[v._v(\"复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。\")]),v._v(\" \"),r(\"p\",[v._v(\"缺点：将内存对半分使用，代价太高。\")]),v._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://pic4.zhimg.com/80/v2-bb9ee29feb22355eed2c1d3ac45606b7_720w.jpg\",alt:\"复制算法\"}})]),v._v(\" \"),r(\"h2\",{attrs:{id:\"标记整理算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#标记整理算法\"}},[v._v(\"#\")]),v._v(\" 标记整理算法\")]),v._v(\" \"),r(\"p\",[v._v(\"将存活的对象整体向前移，再清理掉后面可回收的对象。\")]),v._v(\" \"),r(\"p\",[v._v(\"缺点：对内存的变动更加频繁，效率要差很多。\")]),v._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://pic1.zhimg.com/80/v2-49f3e16de8d552ef585862062abe3f18_720w.jpg\",alt:\"标记整理算法\"}})]),v._v(\" \"),r(\"h2\",{attrs:{id:\"分代收集算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分代收集算法\"}},[v._v(\"#\")]),v._v(\" 分代收集算法\")]),v._v(\" \"),r(\"p\",[v._v(\"分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。\")]),v._v(\" \"),r(\"p\",[v._v(\"对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\")]),v._v(\" \"),r(\"p\",[v._v(\"在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 --- 整理算法来进行回收。\")]),v._v(\" \"),r(\"h3\",{attrs:{id:\"内存模型与回收策略\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存模型与回收策略\"}},[v._v(\"#\")]),v._v(\" 内存模型与回收策略\")]),v._v(\" \"),r(\"p\",[r(\"em\",[v._v(\"Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。\")])]),v._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://pic4.zhimg.com/80/v2-2dcba4d81807c67df8309aa181bb00c3_720w.jpg\",alt:\"内存模型\"}})]),v._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[v._v(\"Eden区：\")]),v._v(\" \"),r(\"p\",[v._v(\"IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。\")]),v._v(\" \"),r(\"p\",[v._v(\"通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。\")])]),v._v(\" \"),r(\"li\",[r(\"p\",[v._v(\"Survivor区：\")]),v._v(\" \"),r(\"p\",[v._v(\"Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。\")]),v._v(\" \"),r(\"blockquote\",[r(\"ol\",[r(\"li\",[r(\"p\",[v._v(\"为啥需要\")]),v._v(\" \"),r(\"p\",[v._v(\"有一些类虽然并不是只用一次，但是也用不了多少次，所以Survivor相当于一个缓冲区，保证只有经历16次Minor GC还能在新生代存活的对象才能进老年区，减少Major GC的发生。\")])]),v._v(\" \"),r(\"li\",[r(\"p\",[v._v(\"为啥需要俩\")]),v._v(\" \"),r(\"p\",[v._v(\"主要是解决内存碎片化。\")]),v._v(\" \"),r(\"p\",[v._v(\"因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。\")]),v._v(\" \"),r(\"p\",[v._v(\"当然更多会导致每块变小，更容易满。\")])])])])]),v._v(\" \"),r(\"li\",[r(\"p\",[v._v(\"Old区：\")]),v._v(\" \"),r(\"p\",[v._v(\"只有在Major的时候才会进行清理，采用标记整理算法。\")]),v._v(\" \"),r(\"p\",[v._v(\"下面几种对象会直接进入到老年代：\")]),v._v(\" \"),r(\"ul\",[r(\"li\",[v._v(\"大对象：即使是使用几次就回收的，是为了防止大内存的复制。\")]),v._v(\" \"),r(\"li\",[v._v(\"长期存活对象：虚拟机定义了对象年龄计数器，每经历一次Minor GC，年龄增加一岁，默认15岁进老年区。\")]),v._v(\" \"),r(\"li\",[v._v(\"动态对象年龄：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\")])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);","extractedComments":[]}